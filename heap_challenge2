<?PHP
namespace{
	//新しいコードを試してみる場所。

	set_time_limit(0);
	function timeCheck(){
		static $beforeCheckTime;
		$newCheckTime=substr(str_pad(hrtime()[0],9,"0",STR_PAD_LEFT).".".str_pad(hrtime()[1],9,"0",STR_PAD_LEFT),4,9);
		if(isset($beforeCheckTime)){$echo=round($newCheckTime-$beforeCheckTime,3);echo "time_$echo<br>\n";}
		$beforeCheckTime=$newCheckTime;
	}
	//../..../..../..../..../..../..../..../..../..
}
namespace{
	//名前空間が分かるような分からないような感じなので試してみるよー。

	//適当な名前空間を設定してinclude
	//include("nstest.txt");
	//ちなみにこんな内容
		// namespace{
		// 	const TEST="TEST0";
		// 	$test="test0";
		// 	function test(){
		// 		return "test0";
		// 	}
		// 	class test{
		// 		const STR="test0";
		// 	}
		// }
		// namespace test1{
		// 	const TEST="TEST1";
		// 	$test="test1";
		// 	function test(){
		// 		return "test1";
		// 	}
		// 	class test{
		// 		const STR="test1";
		// 	}
		// }
		// namespace test1\test2{
		// 	const TEST="TEST2";
		// 	$test="test2";
		// 	function test(){
		// 		return "test2";
		// 	}
		// 	class test{
		// 		const STR="test2";
		// 	}
		// }
	//

	// if(defined("TEST")){echo TEST."\n";}//TEST0
	// if(isset($test)){echo $test."\n";}//test2　変数は、名前空間の影響なしに上書きされてるし呼び出されていることが分かる。
	// if(function_exists("test")){echo test()."\n";}//test0
	// if(class_exists("test")){echo test::STR."\n";}//test0
}
//namespace test1{
	// if(defined("TEST")){echo TEST."\n";}//TEST1
	// if(isset($test)){echo $test."\n";}//test2
	// if(function_exists("test")){echo test()."\n";}//test1
	// if(class_exists("test")){echo test::STR."\n";}//test1
	// //後はもうめんどくさいから定数だけ呼ぶよー。
	// echo"\n";
//}
namespace{
	// echo TEST."\n";//TEST0
	// echo test1\TEST."\n";//TEST1
	// echo test1\test2\TEST."\n";//TEST2
	// use const test1\test2\TEST;
	// echo TEST."\n";//TEST2
}
namespace test3{
	// var_dump(defined("TEST"));//true
	// echo TEST."\n";//TEST0
	// use const test1\test2\TEST;
	// echo TEST."\n";//TEST2
	// use const test1\TEST as TEST3;
	// echo TEST3."\n";//TEST1
}
{
	// namespace{
	// //定数に関しては、大体わかった気がする。
	// //ただ、問題は、引数の型宣言。あれ、非修飾名とか完全修飾名とかいけるもんなんやろか。
	// class tester1{const STR="0";}
	// function tester(tester1 $obj){echo $obj::STR."\n";}
	// }
	// namespace a {
	// 	class tester1{const STR="a";}
	// }
	// namespace b {
	// 	class tester1{const STR="b";}
	// }
	// namespace c{
	// 	function tester(\a\tester1 $obj){echo $obj::STR."\n";}//完全修飾名OK。
	// 	tester(new \a\tester1);//a
	// }
	// namespace{
	// 	function tester_a(a\tester1 $obj){echo $obj::STR."\n";}//修飾名OK。
	// 	tester_a(new a\tester1);//a
	// }
	// namespace a{
	// 	function tester_a(namespace\tester1 $obj){echo $obj::STR."\n";}//非修飾名OK、namespaceキーワードOK。
	// 	tester_a(new tester1);//a
	// }
}
namespace{
//これにより、ほぼ同じコードをちょっとの違いで複数に分ける場合、別の名前空間に入れて型宣言にnamespaceキーワードを入れておけば衝突回避ができる、と。
//よし、場合分けverのヒープ構造を作るぞー。

}
namespace crast\heap{
	class node_unnamed{//名無しノードのベースクラス　このコードでは名有りのみ実装だけど、定義は一応分けておく
		public $value;//内容
		public $key;//優先度
		//protected $kp;//内容配列における優先度の位置
		protected function setup(){}
		public function __construct($value,protected $kp){
			$this->setup();
			$this->setValue($value);
		}
		public function getValue(){
			return $this->value;
		}
		public function setValue($value){
			$this->value=$value;
			$this->key=$value[$this->kp];
		}
		public function getKey(){
			return $this->key;
		}
		public function setKey($key){
			$this->value[$this->kp]=$key;
			$this->key=$key;
		}
	}
	class node extends node_unnamed{//名有りノードのベースクラス
		public $name;//名前
		//protected $kp;//内容配列における優先度の位置
		//protected $np;//内容配列における名前の位置
		protected function setup(){}
		public function __construct($value,protected $kp,protected $np){
			$this->setup();
			$this->setValue($value);
		}
		public function setValue($value){
			$this->value=$value;
			$this->key=$value[$this->kp];
			$this->name=$value[$this->np];//名前設定を追加
		}
		public function getName(){
			return $this->name;
		}
		public function setName($name){
			$this->value[$this->np]=$name;
			$this->name=$name;
		}
	}
	//shellで使うheapオブジェクトのクラスにインターフェイスでも作りたいとこだけど、引数オブジェクトのクラスが未定義なのでできない。
	//shell本体は、heapオブジェクトのクラスを定義した後に定義しないといけないので、また後で。
}
namespace crast\heap\binary{//二部ヒープ本体定義
	class node2 extends \crast\heap\node{
		public $tag;//二部ヒープのヒープ管理番号を入れる
	}
	class node {//速度テスト用の比較用。こっちの方が速いことが多い？キャッシュされるかどうかの差だろうか。
		public $value;//内容
		public $key;//優先度
		public $name;//名前
		public $tag;//二部ヒープのヒープ管理番号を入れる
		//protected $kp;//内容配列における優先度の位置
		//protected $np;//内容配列における名前の位置
		protected function setup(){}
		public function __construct($value,protected $kp,protected $np){
			$this->setup();
			$this->setValue($value);
		}
		public function getValue(){
			return $this->value;
		}
		public function setValue($value){
			$this->value=$value;
			$this->key=$value[$this->kp];
			$this->name=$value[$this->np];
		}
		public function getKey(){
			return $this->key;
		}
		public function setKey($key){
			$this->value[$this->kp]=$key;
			$this->key=$key;
		}
		public function getName(){
			return $this->name;
		}
		public function setName($name){
			$this->value[$this->np]=$name;
			$this->name=$name;
		}
	}
	abstract class common implements \IteratorAggregate,\countable{//昇順・降順問わない共通部分を実装する抽象クラス
		protected $cn;//要素数
		protected $d1_t;//番号ごとに対応するノードを格納する配列
		protected function setup(){
			$this->cn=0;
			$this->d1_t=array();
		}
		public function __construct(){
			$this->setup();
		}
		protected function swap(int $tn1,int $tn2){//番号指定でノード二つを交換する
			//echo"swap $tn1:$tn2\n";
			list($this->d1_t[$tn1],$this->d1_t[$tn2])=array($this->d1_t[$tn2],$this->d1_t[$tn1]);
			$this->d1_t[$tn1]->tag=$tn1;
			$this->d1_t[$tn2]->tag=$tn2;
		}
		abstract protected function alignUp(int $tn):int;//二部ヒープだと、このふたつ以外にcompareしないのね、意外と少ない
		abstract protected function alignDown(int $tn):int;
		public function push(namespace\node $node):int{//ノードで要素を追加する　一応、追加後の位置を返す
			$this->cn++;
			$this->d1_t[$this->cn]=$node;
			$node->tag=$this->cn;
			return $this->alignDown($this->alignUp($this->cn));
		}
		public function prioritize(namespace\node $node,$new):int{//対象ノードの優先度を新しい値に変更して、優先度に基づいた位置に移動させる　一応、移動後の位置を返す
			$node->setKey($new);
			return $this->alignDown($this->alignUp($node->tag));
		}
		public function delete(namespace\node $node){//ノード指定で削除する
			$tn=$node->tag;
			if($tn==$this->cn){
				unset($this->d1_t[$tn]);
				$this->cn--;
			}else{
				$this->d1_t[$tn]=$this->d1_t[$this->cn];
				$this->d1_t[$tn]->tag=$tn;//swapメソッド使わないので、tagの再設定もする
				unset($this->d1_t[$this->cn]);
				$this->cn--;
				$this->alignDown($this->alignUp($tn));
			}
		}
		public function splice(namespace\node $node):namespace\node{//ノード指定で取り出して削除する
			$this->delete($node);
			return $node;
		}
		public function pop():namespace\node{//最優先ノードを取り出して削除する
			return $this->splice($this->d1_t[1]);
		}
		public function top():namespace\node{//最優先ノードを取得する
			return $this->d1_t[1];
		}
		public function count():int{//要素数を返す
			return $this->cn;
		}
		public function getIterator():\Traversable {//この辺も全部グローバル名前空間指定要るのか、まあ当たり前か。
			return new \ArrayIterator($this->d1_t);
		}
		public function clear(){//ヒープを削除する
			$this->setup();
		}
		public function merge(self $heap){//同クラスの対象をこっちにマージする
			$otln=$heap->count;
			for($i1=0;$i1<$otln;$i1++){
				$this->push($heap->pop());
			}
		}
		public function getTree(){//ツリー本体を出力する
			return $this->d1_t;
		}
	}
	class ascending extends namespace\common{//昇順仕様　優先度の数値が小さい方が優先
		protected function alignUp(int $tn):int{//番号指定で、親より優先度が高いなら親と交換、再帰的に繰り返して交換後の番号を返す
			if($tn<2){return $tn;}
			$tn2=floor($tn/2);
			if($this->d1_t[$tn]->key >= $this->d1_t[$tn2]->key){return $tn;}//compare相当

			list($this->d1_t[$tn],$this->d1_t[$tn2])=array($this->d1_t[$tn2],$this->d1_t[$tn]);//swap相当
			$this->d1_t[$tn]->tag=$tn;
			$this->d1_t[$tn2]->tag=$tn2;

			return $this->alignUp($tn2);
		}
		protected function alignDown(int $tn):int{//番号指定で、より優先度の高い子と比較して優先度が低いなら交換、再帰的に繰り返して交換後の番号を返す
			if($tn*2>$this->cn){return $tn;}
			elseif($tn*2==$this->cn){$tn2=$tn*2;}
			else{
				if($this->d1_t[$tn*2]->key > $this->d1_t[$tn*2+1]->key){$tn2=$tn*2+1;}//compare相当
				else{$tn2=$tn*2;}
			}
			if($this->d1_t[$tn]->key <= $this->d1_t[$tn2]->key){return $tn;}//compare相当

			list($this->d1_t[$tn],$this->d1_t[$tn2])=array($this->d1_t[$tn2],$this->d1_t[$tn]);//swap相当
			$this->d1_t[$tn]->tag=$tn;
			$this->d1_t[$tn2]->tag=$tn2;

			return $this->alignDown($tn2);
		}
	}
	class descending extends namespace\common{//降順仕様　優先度の数値が大きい方が優先
		protected function alignUp(int $tn):int{//番号指定で、親より優先度が高いなら親と交換、再帰的に繰り返して交換後の番号を返す
			if($tn<2){return $tn;}
			$tn2=floor($tn/2);
			if($this->d1_t[$tn]->key <= $this->d1_t[$tn2]->key){return $tn;}//compare相当

			list($this->d1_t[$tn],$this->d1_t[$tn2])=array($this->d1_t[$tn2],$this->d1_t[$tn]);//swap相当
			$this->d1_t[$tn]->tag=$tn;
			$this->d1_t[$tn2]->tag=$tn2;

			return $this->alignUp($tn2);
		}
		protected function alignDown(int $tn):int{//番号指定で、より優先度の高い子と比較して優先度が低いなら交換、再帰的に繰り返して交換後の番号を返す
			if($tn*2>$this->cn){return $tn;}
			elseif($tn*2==$this->cn){$tn2=$tn*2;}
			else{
				if($this->d1_t[$tn*2]->key < $this->d1_t[$tn*2+1]->key){$tn2=$tn*2+1;}//compare相当
				else{$tn2=$tn*2;}
			}
			if($this->d1_t[$tn]->key >= $this->d1_t[$tn2]->key){return $tn;}//compare相当

			list($this->d1_t[$tn],$this->d1_t[$tn2])=array($this->d1_t[$tn2],$this->d1_t[$tn]);//swap相当
			$this->d1_t[$tn]->tag=$tn;
			$this->d1_t[$tn2]->tag=$tn2;

			return $this->alignDown($tn2);
		}
	}
}
namespace crast\heap\binomial{//二項ヒープ本体定義
	class node{
		public $value;//内容
		public $key;//優先度
		public $name;//名前
		public $degree;//次数　直接操作のみ　常に、0から次数―1までの次数個の子を持つ
		public $parent;//親ノード　直接操作のみ
		public $child;//子ノード配列　直接操作のみ　[0]には0次の、[1]には1次の子ノードが入る
		//protected $kp;//内容配列における優先度の位置
		//protected $np;//内容配列における名前の位置
		protected function setup(){
			$this->degree=0;
			$this->child=array();
		}
		public function __construct($value,protected $kp,protected $np){
			$this->setup();
			$this->setValue($value);
		}
		public function getValue(){
			return $this->value;
		}
		public function setValue($value){
			$this->value=$value;
			$this->key=$value[$this->kp];
			$this->name=$value[$this->np];
		}
		public function getKey(){
			return $this->key;
		}
		public function setKey($key){
			$this->value[$this->kp]=$key;
			$this->key=$key;
		}
		public function getName(){
			return $this->name;
		}
		public function setName($name){
			$this->value[$this->np]=$name;
			$this->name=$name;
		}

	}
	abstract class common implements \Iterator,\countable{//昇順・降順問わない共通部分を実装する抽象クラス
		protected $cn;//要素数
		protected $R;//全ての親ノード　例外的に、子に空きができる
		protected $itr;//Iterator用のスタック
		protected $itrn;//Iterator用のカウント変数
		public $shell;//対応するshellオブジェクト
		protected function setup(){
			$this->cn=0;
			$this->R=new namespace\node(array("ROOT",0),1,0);
			$this->R->parent=$this->R;
			$this->R->belong=$this;
		}
		public function __construct(){
			$this->setup();
		}
		protected function swapToUpper(namespace\node $node):namespace\node{//ノード指定で親と位置を交換して、交換後のノードを返す　すべての親とは交換しない　
			$parent=$node->parent;
			if($node->parent==$this->R){return false;}
			$parent->parent->child[$parent->degree]=$node;//親の親からの参照を修正
			foreach($node->child as $fenode){//対象の子からの参照を修正
				$fenode->parent=$parent;
			}
			foreach($parent->child as $fenode){//対象を含む、親の子からの参照を修正
				$fenode->parent=$node;
			}
			$parent->child[$node->degree]=$parent;//親から対象への参照を修正
	
			//対象と親の構造情報を交換
			list($node->child,$parent->child)=array($parent->child,$node->child);
			list($node->parent,$parent->parent)=array($parent->parent,$node->parent);
			list($node->degree,$parent->degree)=array($parent->degree,$node->degree);
			return $node;
		}
		abstract protected function alignUp(namespace\node $node):namespace\node;//ノード指定で、親より優先度が高いなら親と交換、再帰的に繰り返して交換後のノードを返す
		abstract protected function alignDown(namespace\node $node):namespace\node;//ノード指定で、より優先度の高い子と比較して優先度が低いなら交換、再帰的に繰り返して交換後のノードを返す
		protected function extend(namespace\node $child,namespace\node $parent){//親無しのchildをparentの子に加える
			//childの親からの参照は操作しない
			$parent->child[$parent->degree]=$child;
			$parent->degree++;
			$child->parent=$parent;
		}
		public function push(namespace\node $node){//ノードで0次要素をヒープに追加する
			$this->cn++;
			$this->add($node);
		}
		abstract protected function add(namespace\node $node):int;//親無しのノードをルートに追加する　最終的に追加された次数を返す
		public function prioritize(namespace\node $node,$new){//対象ノードの優先度を新しい値に変更して、優先度に基づいた位置に移動させる
			$node->setKey($new);
			$this->alignDown($this->alignUp($node));
		}
		abstract public function top():namespace\node;//最優先ノードを取得する
		protected function deleteRoot(namespace\node $node){//指定されたルートノードを削除する
			if($node->parent!=$this->R){return false;}
	
			$this->R->child[$node->degree]=null;
	
			for($i1=$node->degree-1;$i1>=0;$i1--){
				$this->add($node->child[$i1]);
			}
		}
		public function pop():namespace\node{//最優先ノードを取り出して削除する
			$rtobj=$this->top();
			$this->deleteRoot($rtobj);
			$rtobj->parent=null;
			$rtobj->child=array();
			$rtobj->degree=0;
			$this->cn--;
			return $rtobj;
		}
		public function delete(namespace\node $node){//ノード指定で削除する
			while($node->parent!=$this->R){
				$node=$this->swapToUpper($node);
			}
			$this->deleteRoot($node);
		}
		public function splice(namespace\node $node):namespace\node{//ノード指定で取り出して削除する
			$rtobj=$node;
			$this->delete($node);
			$rtobj->parent=null;
			$rtobj->child=array();
			$rtobj->degree=0;
			return $rtobj;
		}
		public function inThis(namespace\node $node):bool{//このオブジェクトの全ての親に繋がるノードかどうか判定する
			$obj=$node;
			while($obj!=$obj->parent){
				$obj=$obj->parent;
				if(!is_a($obj,"binomialHeapNode")){return false;}
			}
			if($obj==$this->R){return true;}
			else{return false;}
		}
		public function count():int{//要素数を返す
			return $this->cn;
		}
	
		//Iteratorインターフェイス
			public function current(): mixed{
				return $this->itr->top();
			}
			public function key(): mixed{
				return $this->itrn;
			}
			public function next(): void{
				$otobj=$this->itr->pop();
				for($i2=$otobj->degree-1;$i2>=0;$i2--){
					$this->itr->push($otobj->child[$i2]);
				}
				$this->itrn++;
			}
			public function rewind(): void{
				$this->itr=new \SplStack();
				$this->itrn=0;
				if($this->count()==0){return;}
				$otar=array_reverse(array_keys($this->R->child));
				foreach($otar as $fen){
					if($this->R->child[$fen]===null){continue;}
					$this->itr->push($this->R->child[$fen]);
				}
			}
			public function valid(): bool{
				return $this->itr->count()>0;
			}
		//
		public function clear(){//ヒープを削除する
			$this->setup();
		}
		public function getRoot():namespace\node{
			return $this->R;
		}
		public function merge(self $heap){//同クラスの対象をこっちにマージする
			$terget=$heap->getRoot();
			$otar=array_reverse(array_keys($terget->child));
			foreach($otar as $fen){
				if($terget->child[$fen]===null){continue;}
				$this->add($terget->child[$fen]);
			}
			$this->cn+=$heap->count();
		}
	}
	class ascending extends namespace\common{//昇順仕様　優先度の数値が小さい方が優先
		protected function alignUp(namespace\node $node):namespace\node{//ノード指定で、親より優先度が高いなら親と交換、再帰的に繰り返して交換後のノードを返す
			if($node->parent==$this->R){return $node;}
			if($node->getKey() < $node->parent->getKey()){//compare相当処理
				$node=$this->swapToUpper($node);
				return $this->alignUp($node);
			}else{
				return $node;
			}
		}
		protected function alignDown(namespace\node $node):namespace\node{//ノード指定で、より優先度の高い子と比較して優先度が低いなら交換、再帰的に繰り返して交換後のノードを返す
			if($node->degree==0){return $node;}
			$z_max=$node->child[0];
			for($i1=1;$i1<=$node->degree-1;$i1++){
				if($node->child[$i1]->getKey() < $z_max->getKey()){//compare相当処理
					$z_max=$node->child[$i1];
				}
			}
			if($node->getKey() > $z_max->getKey()){//compare相当処理
				$this->swapToUpper($z_max);
				return $this->alignDown($z_max);
			}else{
				return $node;
			}
		}
		protected function add(namespace\node $node):int{//親無しのノードをルートに追加する　最終的に追加された次数を返す
			//nodeの親からの参照は操作しない。先に消しておくこと
			$dn=$node->degree;
			$node->parent=$this->R;
			while(true){
				if(isset($this->R->child[$dn])){
					$terget=$this->R->child[$dn];
					$this->R->child[$dn]=null;
					if($node->getKey()<$terget->getKey()){//compare相当処理
						$this->extend($terget,$node);
						$dn++;
						continue;
					}else{
						$this->extend($node,$terget);
						$dn++;
						$node=$terget;
						continue;
					}
				}else{
					$this->R->child[$dn]=$node;
					return $dn;
				}
			}
		}
		public function top():namespace\node{//最優先ノードを取得する
			if($this->cn==0){return false;}
	
			$rtobj=null;
			foreach($this->R->child as $feobj){//全ての親の子の中から、最優先のものを探す
				if($rtobj===null){
					$rtobj=$feobj;
				}elseif($feobj===null){
				}elseif($feobj->getKey()<$rtobj->getKey()){//compare相当処理
					$rtobj=$feobj;
				}
			}
			return $rtobj;
		}
	}
	class descending extends namespace\common{//降順仕様　優先度の数値が大きい方が優先
		protected function alignUp(namespace\node $node):namespace\node{//ノード指定で、親より優先度が高いなら親と交換、再帰的に繰り返して交換後のノードを返す
			if($node->parent==$this->R){return $node;}
			if($node->getKey() > $node->parent->getKey()){//compare相当処理
				$node=$this->swapToUpper($node);
				return $this->alignUp($node);
			}else{
				return $node;
			}
		}
		protected function alignDown(namespace\node $node):namespace\node{//ノード指定で、より優先度の高い子と比較して優先度が低いなら交換、再帰的に繰り返して交換後のノードを返す
			if($node->degree==0){return $node;}
			$z_max=$node->child[0];
			for($i1=1;$i1<=$node->degree-1;$i1++){
				if($node->child[$i1]->getKey() > $z_max->getKey()){//compare相当処理
					$z_max=$node->child[$i1];
				}
			}
			if($node->getKey() < $z_max->getKey()){//compare相当処理
				$this->swapToUpper($z_max);
				return $this->alignDown($z_max);
			}else{
				return $node;
			}
		}
		protected function add(namespace\node $node):int{//親無しのノードをルートに追加する　最終的に追加された次数を返す
			//nodeの親からの参照は操作しない。先に消しておくこと
			$dn=$node->degree;
			$node->parent=$this->R;
			while(true){
				if(isset($this->R->child[$dn])){
					$terget=$this->R->child[$dn];
					$this->R->child[$dn]=null;
					if($node->getKey() > $terget->getKey()){//compare相当処理
						$this->extend($terget,$node);
						$dn++;
						continue;
					}else{
						$this->extend($node,$terget);
						$dn++;
						$node=$terget;
						continue;
					}
				}else{
					$this->R->child[$dn]=$node;
					return $dn;
				}
			}
		}
		public function top():namespace\node{//最優先ノードを取得する
			if($this->cn==0){return false;}
	
			$rtobj=null;
			foreach($this->R->child as $feobj){//全ての親の子の中から、最優先のものを探す
				if($rtobj===null){
					$rtobj=$feobj;
				}elseif($feobj===null){
				}elseif($feobj->getKey() > $rtobj->getKey()){//compare相当処理
					$rtobj=$feobj;
				}
			}
			return $rtobj;
		}
	}
}
namespace crast\heap\fibonacci{//フィボナッチヒープ本体定義
	class node{
		public $value;//内容
		public $key;//優先度
		public $name;//名前
		//protected $kp;//内容配列における優先度の位置
		//protected $np;//内容配列における名前の位置
		public $degree;//子リンクの要素数
		public $damaged=false;//ダメージがあるならtrue
		public $parent;//親ノード
		public $child;//最優先子ノード配列
		public $next;//弟ノード
		public $prev;//兄ノード
		protected function setup(){
			$this->degree=0;
		}
		public function __construct($value,protected $kp,protected $np){
			$this->setup();
			$this->setValue($value);
		}
		public function getValue(){
			return $this->value;
		}
		public function setValue($value){
			$this->value=$value;
			$this->key=$value[$this->kp];
			$this->name=$value[$this->np];
		}
		public function getKey(){
			return $this->key;
		}
		public function setKey($key){
			$this->value[$this->kp]=$key;
			$this->key=$key;
		}
		public function getName(){
			return $this->name;
		}
		public function setName($name){
			$this->value[$this->np]=$name;
			$this->name=$name;
		}
	}
	abstract class common implements \Iterator,\countable{
		protected $cn;//要素数
		protected $R;//全ての親ノード
		//protected $rule;//0なら優先度が低いほど優先、1なら優先度が高いほど優先
		protected $itr;//Iterator用のスタック
		protected $itrn;//Iterator用のカウント変数
		public $shell;//対応するfibonacciHeapオブジェクト
		protected $d1_m;//orgaize時に一旦整列させるための配列
		protected function setup(){
			$this->cn=0;
			$this->R=new namespace\node(array(0,"ROOT"),0,1);//全ての親の名前はshellからは参照されないがデバッグ的に必要
			$this->R->parent=$this->R;
			$this->R->belong=$this;
			$this->d1_m=array();
		}
		public function __construct(protected $rule=0){
			$this->setup();
		}
		abstract protected function setMaxChild(namespace\node $parent);//対象の子リンクの最優先ノードを更新する　organizeまではしない
		protected function cutRoot(namespace\node $node,$flag=true){//対象ノードを、親の子リンクから外し、trueならルートノード末尾に加える　親無しのノードだとエラー
			if($node===$this->R){return;}

			$parent=$node->parent;

			if($node->next!==$node){//兄弟がいる場合、リンク切断処理が入る

				if($parent->child===$node){//兄弟内での最優先ノードだった場合、最優先ノード更新処理が入る
					$next=$node->next;//とりあえず子のひとつを抽出しておく
				}else{
					$next=false;
				}

				$node->prev->next=$node->next;
				$node->next->prev=$node->prev;

				$node->next=null;
				$node->prev=null;

				if($next){//リンク切断処理の後に、最優先ノード更新処理。
					$parent->child=$next;//対象が最優先ノードだったときのみ、親の子は変更される
					$this->setMaxChild($parent);
				}

			}else{
				$parent->child=null;//兄弟がいない場合、親の子は無くなる
			}
			$parent->degree--;
			if($flag){$this->putNode($node);}
			else{$node->parent=null;}

			if($parent->parent===$this->R){return;}//全ての親とルートノードにダメージ判定は無い
	
			if($parent->damaged){//親のダメージ次第で連鎖的に切断する
				$this->cutRoot($parent);//連鎖的に切断する分は自動的にルートノードに追加する
			}else{
				$parent->damaged=true;
			}
		}
		abstract protected function putNode(namespace\node $child,namespace\node $parent=null);//単独ノードをparentの子リンク末尾に追加する。childの元の親からの参照には触れない
		abstract protected function linkRoot(namespace\node $child,namespace\node $parent=null);//childを兄弟リンクごとparentの子リンクに追加する。childの元の親からの参照には触れない
		abstract protected function organize_rc(namespace\node $node);//d1_mに、繰上り込みで統合する　最終的にd1_mに入ったノードを返す
		public function organize(){//ルートリンクの、次数が同じ木を統合する
			$terget=$this->R->child;
			do{
				$next=$terget->next;
				$this->organize_rc($terget);
				$terget=$next;
			}while($terget!==$this->R->child);

			$this->d1_m=array();
		}
		public function push(namespace\node $node){//ノードで0次要素をヒープに追加する
			$this->cn++;
			$this->putNode($node);
		}
		abstract public function prioritize(namespace\node $node,$new);//対象ノードの優先度を新しい値に変更して、必要に応じて親子関係を切断する
		public function top():namespace\node{//最優先ノードを取得する
			//echo"top\n";
			if($this->cn==0){return false;}
			return $this->R->child;
		}
		protected function delete(namespace\node $node){//指定されたノードを削除する
			//echo"delete\n";
			$this->cn--;//分岐の前に確実に要素数減少処理
			$this->cutRoot($node,false);
	
			if($node->child===null){return;}//対象に子があるとは限らない。
	
			$this->linkRoot($node->child);
			$node->child=null;
		}
		public function pop():namespace\node{//最優先ノードを取り出して削除する
			if($this->cn==0){return false;}
			$this->organize();
			$rtobj=$this->top();
			$this->delete($rtobj);
			return $rtobj;
		}
		public function splice(namespace\node $node):namespace\node{//ノード指定で取り出して削除する
			$rtobj=$node;
			$this->delete($node);
			return $rtobj;
		}
		public function inThis(namespace\node $node):bool{//このオブジェクトの全ての親に繋がるノードかどうか判定する
			$obj=$node;
			while($obj!=$obj->parent){
				$obj=$obj->parent;
				if(!is_a($obj,"namespace\node")){return false;}
			}
			if($obj===$this->R){return true;}
			else{return false;}
		}
		public function count():int{//要素数を返す
			return $this->cn;
		}
		//Iteratorインターフェイス
			public function current(): mixed{
				return $this->itr->top();
			}
			public function key(): mixed{
				return $this->itrn;
			}
			public function next(): void{
				$first=$this->itr->pop()->child;
				if($first===null){return;}
	
				$terget=$first;
				do{
					$terget=$terget->prev;
					$this->itr->push($terget);
				}while($terget!==$first);
				$this->itrn++;
			}
			public function rewind(): void{
				$this->itr=new \SplStack();
				$this->itrn=0;
				$this->itr->push($this->R);
				$this->next();
			}
			public function valid(): bool{
				return $this->itr->count()>0;
			}
		//
		public function clear(){//ヒープを削除する
			$this->setup();
		}
		public function getRoot():namespace\node{
			return $this->R;
		}
		public function merge(self $heap){//同クラスの対象をこっちにマージする
			$this->linkRoot($heap->getRoot()->child);
			$this->cn+=$heap->count();
			$heap->clear();
		}
	}
	class ascending extends namespace\common{//昇順仕様　優先度の数値が小さい方が優先
		protected function setMaxChild(namespace\node $parent){//対象の子リンクの最優先ノードを更新する　organizeまではしない
			$first=$parent->child;
			if($first===null){return;}

			$terget=$first;
			$z_max=$terget;
			while($terget->next!==$first){
				$terget=$terget->next;
				if($terget->getKey()<$z_max->getkey()){//compare相当処理
					$z_max=$terget;
				}
			}
			$parent->child=$z_max;
		}
		protected function putNode(namespace\node $child,namespace\node $parent=null){//単独ノードをparentの子リンク末尾に追加する。childの元の親からの参照には触れない
			if($child===$this->R){return;}

			if($parent===null){
				$parent=$this->R;
				$flag=true;
			}else{
				$flag=false;
			}

			$child->parent=$parent;
			if($flag){$child->damaged=false;}
			$parent->degree++;

			if($parent->child===null){
				$parent->child=$child;
				$child->next=$child;//一人で兄弟リンクを形成する
				$child->prev=$child;
			}else{
				$child->prev=$parent->child->prev;
				$parent->child->prev->next=$child;
				$child->next=$parent->child;
				$parent->child->prev=$child;
				if($child->getKey()<$parent->child->getkey()){//compare相当処理
					$parent->child=$child;
				}
			}
		}
		protected function linkRoot(namespace\node $child,namespace\node $parent=null){//childを兄弟リンクごとparentの子リンクに追加する。childの元の親からの参照には触れない
			if($child===$this->R){return;}
			if($parent===null){
				$parent=$this->R;
				$flag=true;
			}else{
				$flag=false;
			}

			$terget=$child;//兄弟全員分の親を変更する
			$dn=0;//ついでに、加算される次数を数える
			do{
				$dn++;
				$terget->parent=$parent;
				$terget=$terget->next;
				if($flag){$terget->damaged=false;}//ルートノードになる際にダメージは無くなる
			}while($terget!==$child);

			if($parent->child===null){
				$parent->child=$child;
			}else{
				list($child->prev,$parent->child->prev)=array($parent->child->prev,$child->prev);
				$child->prev->next=$child;
				$parent->child->prev->next=$parent->child;

				if($child->getKey()<$parent->child->getkey()){//compare相当処理
					$parent->child=$child;
				}
			}

			$parent->degree+=$dn;//親の次数を修正
		}
		protected function organize_rc(namespace\node $node){//d1_mに、繰上り込みで統合する　最終的にd1_mに入ったノードを返す
			$dn=$node->degree;
			if(isset($this->d1_m[$dn])){
				if($node===$this->R->child){//最優先ノードなら、同優先度だろうと何だろうと優先
					$this->cutRoot($this->d1_m[$dn],false);
					$this->putNode($this->d1_m[$dn],$node);
				}elseif($node->getKey()<$this->d1_m[$dn]->getkey()){//compare相当処理
					$this->cutRoot($this->d1_m[$dn],false);
					$this->putNode($this->d1_m[$dn],$node);
				}else{
					$this->cutRoot($node,false);
					$this->putNode($node,$this->d1_m[$dn]);
					$node=$this->d1_m[$dn];
				}
				unset($this->d1_m[$dn]);
				return $this->organize_rc($node);
			}else{
				$this->d1_m[$dn]=$node;
				return $node;
			}
		}
		public function prioritize(namespace\node $node,$new){//対象ノードの優先度を新しい値に変更して、必要に応じて親子関係を切断する
			if($new==$node->getKey()){
				return;
			}elseif($new<$node->getKey()){//compare相当処理
				$this->priorityUp($node,$new);
			}else{
				$this->priorityDown($node,$new);
			}
		}
		public function priorityUp(namespace\node $node,$new){//対象ノードの優先度を上昇させ、親を超えていれば切り離す
			$node->setKey($new);
			if($node->parent!==$this->R and $node->getKey()<$node->parent->getKey()){//compare相当処理 ルートノードなら親とは比較しない
				$this->cutRoot($node);
			}else{//親と切り離されなかった場合、子リンクの中での最優先ノードの変更の可能性があるので処理
				if($node->getKey()<$node->parent->child->getKey()){//compare相当処理
					$node->parent->child=$node;
				}
			}
		}
		public function priorityDown(namespace\node $node,$new){//対象ノードの優先度を減少させ、子を割っていれば切り離す
			$node->setKey($new);
			if($node->parent->child===$node){//最優先ノードだった場合、子リンクの中での最優先ノードの変更の可能性があるので処理
				$this->setMaxChild($node->parent);
			}
			if($node->child!==null and $node->getKey()>$node->child->getKey()){////compare相当処理 子が無いなら子とは比較しない
				$this->linkRoot($node->child);
				$node->child=null;
				$node->degree=0;//linkRootは対象の親を操作しないので、こっちで色々やっておく
			}
		}
	}
	class descending extends namespace\common{//降順仕様　優先度の数値が大きい方が優先
		protected function setMaxChild(namespace\node $parent){//対象の子リンクの最優先ノードを更新する　organizeまではしない
			$first=$parent->child;
			if($first===null){return;}

			$terget=$first;
			$z_max=$terget;
			while($terget->next!==$first){
				$terget=$terget->next;
				if($terget->getKey() > $z_max->getkey()){//compare相当処理
					$z_max=$terget;
				}
			}
			$parent->child=$z_max;
		}
		protected function putNode(namespace\node $child,namespace\node $parent=null){//単独ノードをparentの子リンク末尾に追加する。childの元の親からの参照には触れない
			if($child===$this->R){return;}

			if($parent===null){
				$parent=$this->R;
				$flag=true;
			}else{
				$flag=false;
			}

			$child->parent=$parent;
			if($flag){$child->damaged=false;}
			$parent->degree++;

			if($parent->child===null){
				$parent->child=$child;
				$child->next=$child;//一人で兄弟リンクを形成する
				$child->prev=$child;
			}else{
				$child->prev=$parent->child->prev;
				$parent->child->prev->next=$child;
				$child->next=$parent->child;
				$parent->child->prev=$child;
				if($child->getKey() > $parent->child->getkey()){//compare相当処理
					$parent->child=$child;
				}
			}
		}
		protected function linkRoot(namespace\node $child,namespace\node $parent=null){//childを兄弟リンクごとparentの子リンクに追加する。childの元の親からの参照には触れない
			if($child===$this->R){return;}
			if($parent===null){
				$parent=$this->R;
				$flag=true;
			}else{
				$flag=false;
			}

			$terget=$child;//兄弟全員分の親を変更する
			$dn=0;//ついでに、加算される次数を数える
			do{
				$dn++;
				$terget->parent=$parent;
				$terget=$terget->next;
				if($flag){$terget->damaged=false;}//ルートノードになる際にダメージは無くなる
			}while($terget!==$child);

			if($parent->child===null){
				$parent->child=$child;
			}else{
				list($child->prev,$parent->child->prev)=array($parent->child->prev,$child->prev);
				$child->prev->next=$child;
				$parent->child->prev->next=$parent->child;

				if($child->getKey() > $parent->child->getkey()){//compare相当処理
					$parent->child=$child;
				}
			}

			$parent->degree+=$dn;//親の次数を修正
		}
		protected function organize_rc(namespace\node $node){//d1_mに、繰上り込みで統合する　最終的にd1_mに入ったノードを返す
			$dn=$node->degree;
			if(isset($this->d1_m[$dn])){
				if($node===$this->R->child){//最優先ノードなら、同優先度だろうと何だろうと優先
					$this->cutRoot($this->d1_m[$dn],false);
					$this->putNode($this->d1_m[$dn],$node);
				}elseif($node->getKey() > $this->d1_m[$dn]->getkey()){//compare相当処理
					$this->cutRoot($this->d1_m[$dn],false);
					$this->putNode($this->d1_m[$dn],$node);
				}else{
					$this->cutRoot($node,false);
					$this->putNode($node,$this->d1_m[$dn]);
					$node=$this->d1_m[$dn];
				}
				unset($this->d1_m[$dn]);
				return $this->organize_rc($node);
			}else{
				$this->d1_m[$dn]=$node;
				return $node;
			}
		}
		public function prioritize(namespace\node $node,$new){//対象ノードの優先度を新しい値に変更して、必要に応じて親子関係を切断する
			if($new==$node->getKey()){
				return;
			}elseif($new > $node->getKey()){//compare相当処理
				$this->priorityUp($node,$new);
			}else{
				$this->priorityDown($node,$new);
			}
		}
		public function priorityUp(namespace\node $node,$new){//対象ノードの優先度を上昇させ、親を超えていれば切り離す
			$node->setKey($new);
			if($node->parent!==$this->R and $node->getKey() > $node->parent->getKey()){//compare相当処理 ルートノードなら親とは比較しない
				$this->cutRoot($node);
			}else{//親と切り離されなかった場合、子リンクの中での最優先ノードの変更の可能性があるので処理
				if($node->getKey() > $node->parent->child->getKey()){//compare相当処理
					$node->parent->child=$node;
				}
			}
		}
		public function priorityDown(namespace\node $node,$new){//対象ノードの優先度を減少させ、子を割っていれば切り離す
			$node->setKey($new);
			if($node->parent->child===$node){//最優先ノードだった場合、子リンクの中での最優先ノードの変更の可能性があるので処理
				$this->setMaxChild($node->parent);
			}
			if($node->child!==null and $node->getKey() < $node->child->getKey()){//compare相当処理 子が無いなら子とは比較しない
				$this->linkRoot($node->child);
				$node->child=null;
				$node->degree=0;//linkRootは対象の親を操作しないので、こっちで色々やっておく
			}
		}
	}

}

namespace crast\heap{//shell定義
	class shell implements \IteratorAggregate,\countable{
		protected $d1_n;//名前→ノード配列
		protected $heap;//binaryHeapObjオブジェクト
		protected const TYPE=array(0=>"binary",1=>"binomial",2=>"fibonacci");
		protected $heapName;
		protected const RULE=array(-1=>"test",0=>"ascending",1=>"descending");
		protected $nodeName;
		protected $kp;//内容配列における優先度の位置
		protected $np;//内容配列における名前の位置
		protected function setup(){
			$this->d1_n=array();
		}
		public function __construct($rule, $key_position, $name_position, $heap_type=0){
			$this->setup();
			$this->kp=$key_position;
			$this->np=$name_position;
			$this->heapName=__NAMESPACE__."\\".self::TYPE[$heap_type]."\\".self::RULE[$rule];
			$this->nodeName=__NAMESPACE__."\\".self::TYPE[$heap_type]."\\node";
			$this->heap=new ($this->heapName)();//使用するヒープの名前を動的に生成
			$this->heap->shell=$this;//ヒープオブジェクトからこちらを認識できるようにしておく
		}
		public function swapNode($name1,$name2){
			if(array_key_exists($name1,$this->d1_n) and array_key_exists($name2,$this->d1_n)){
				list($this->d1_n[$name1],$this->d1_n[$name2])=array($this->d1_n[$name2],$this->d1_n[$name1]);
			}
		}
		public function push(array $d1_v):bool{//内容配列からノードを生成、名前→ノード配列とヒープ本体に追加する
			if(isset($this->d1_n[$d1_v[$this->np]])){return false;}
			$node=new ($this->nodeName)($d1_v,$this->kp,$this->np);
			$this->d1_n[$node->getName()]=$node;
			$this->heap->push($node);
			return true;
		}
		public function change($d1_v):bool{//内容配列で同名ノードの内容を上書き
			$name=$d1_v[$this->np];
			if(!isset($this->d1_n[$name])){return false;}
			$this->d1_n[$name]->setValue($d1_v);
			$this->heap->prioritize($this->d1_n[$name],$d1_v[$this->kp]);
			return true;
		}
		public function write($d1_v){//内容配列で追加、できなければ上書き
			if($this->push($d1_v)===false){$this->change($d1_v);}
		}
		public function rename($old,$new):bool{//名前で指定したノードの名前だけを変更
			if(!isset($this->d1_n[$old])){return false;}
			if(isset($this->d1_n[$new])){return false;}
			$this->d1_n[$new]=$this->d1_n[$old];
			unset($this->d1_n[$old]);
			$this->d1_n[$new]->setName($new);
			return true;
		}
		public function top():array{//最優先ノードの内容を出力
			return $this->heap->top()->getValue();
		}
		public function pop():array{//最優先ノードの内容を出力して削除
			$node=$this->heap->pop();
			unset($this->d1_n[$node->getName()]);
			return $node->getValue();
		}
		public function delete($name){//名前で指定したノードを削除
			if(!isset($this->d1_n[$name])){return false;}
			$this->heap->delete($this->d1_n[$name]);
			unset($this->d1_n[$name]);
		}
		public function splice($name):array{//名前で指定したノードの内容を出力して削除
			if(!isset($this->d1_n[$name])){return false;}
			$node=$this->d1_n[$name];//出力内容の退避
			$this->delete($name);
			return $node->getValue;
		}
		public function prioritize($name,$new):bool{//名前指定で優先度変更
			if(!isset($this->d1_n[$name])){return false;}
			$this->heap->prioritize($this->d1_n[$name],$new);
			return true;
		}
		public function count():int{
			return $this->heap->count();
		}
		public function getIterator():\Traversable {
			return new \ArrayIterator($this->d1_n);
		}
		public function getHeap(){
			return $this->heap;
		}
		public function merge(self $obj){//名前被りは一切考慮していない
			if($this->np!==null){
				foreach($obj as $name=>$node){
					$this->d1_n[$name]=$node;
				}
			}
			$this->heap->merge($obj->getHeap());
		}
		public function getList(){//名前→内容配列を出力する
			$d2_rt=array();
			foreach($this->d1_n as $key=>$node){
				$d2_rt[$key]=$node->getValue();
			}
			return $d2_rt;
		}
	}
}
namespace oldcode{
	class heapNode{
		public $value;//内容
		public $key;//優先度
		public $name;//名前
		//protected $kp;//内容配列における優先度の位置
		//protected $np;//内容配列における名前の位置
		protected function setup(){}
		public function __construct($value,protected $kp,protected $np=null){
			$this->setup();
			$this->setValue($value);
		}
		public function getValue(){
			return $this->value;
		}
		public function setValue($value){
			$this->value=$value;
			$this->key=$value[$this->kp];
			if($this->np!==null){
				$this->name=$value[$this->np];
			}
		}
		public function getKey(){
			return $this->key;
		}
		public function setKey($key){
			$this->value[$this->kp]=$key;
			$this->key=$key;
		}
		public function getName(){
			return $this->name;
		}
		public function setName($name){
			$this->value[$this->np]=$name;
			$this->name=$name;
		}
	}
	class binaryHeapNode extends heapnode{
		public $tag;//管理用の番号
	}
	class binaryHeapObj implements \IteratorAggregate,\countable{
		protected $cn;//要素数
		protected $d1_t;//番号ごとに対応するノードを格納する配列
		//protected $rule;//0なら優先度が低いほど優先、1なら優先度が高いほど優先
		protected function setup(){
			$this->cn=0;
			$this->d1_t=array();
		}
		public function __construct(protected $rule=0){
			$this->setup();
		}
		protected function compare(int $tn1,int $tn2){//番号で比較、tn1の方が優先なら1、tn2の方が優先なら-1
			$kn1=$this->d1_t[$tn1]->getKey();
			$kn2=$this->d1_t[$tn2]->getKey();
			//echo "compare $tn1:$kn1 , $tn2:$kn2\n";
	
			if($this->rule==0){
				if($kn1<$kn2){return 1;}
				elseif($kn1>$kn2){return -1;}
				elseif($kn1==$kn2){return 0;}
			}else{
				if($kn1<$kn2){return -1;}
				elseif($kn1>$kn2){return 1;}
				elseif($kn1==$kn2){return 0;}
			}
		}
		protected function swap(int $tn1,int $tn2){//番号指定でノード二つを交換する
			//echo"swap $tn1:$tn2\n";
			list($this->d1_t[$tn1],$this->d1_t[$tn2])=array($this->d1_t[$tn2],$this->d1_t[$tn1]);
			$this->d1_t[$tn1]->tag=$tn1;
			$this->d1_t[$tn2]->tag=$tn2;
		}
		protected function alignUp(int $tn):int{//番号指定で、親より優先度が高いなら親と交換、再帰的に繰り返して交換後の番号を返す
			if($tn<2){return $tn;}
			$tn2=floor($tn/2);
			if($this->compare($tn,$tn2)<=0){return $tn;}
			$this->swap($tn,$tn2);
			return $this->alignUp($tn2);
		}
		protected function alignDown(int $tn):int{//番号指定で、より優先度の高い子と比較して優先度が低いなら交換、再帰的に繰り返して交換後の番号を返す
			if($tn*2>$this->cn){return $tn;}
			elseif($tn*2==$this->cn){$tn2=$tn*2;}
			else{
				if($this->compare($tn*2,$tn*2+1)<0){$tn2=$tn*2+1;}
				else{$tn2=$tn*2;}
			}
			if($this->compare($tn,$tn2)>=0){return $tn;}
			$this->swap($tn,$tn2);
			return $this->alignDown($tn2);
		}
		public function push(binaryHeapNode $node):int{//ノードで要素を追加する　一応、追加後の位置を返す
			$this->cn++;
			$this->d1_t[$this->cn]=$node;
			$node->tag=$this->cn;
			return $this->alignDown($this->alignUp($this->cn));
		}
		public function prioritize(binaryHeapNode $node,$new):int{//対象ノードの優先度を新しい値に変更して、優先度に基づいた位置に移動させる　一応、移動後の位置を返す
			$node->setKey($new);
			return $this->alignDown($this->alignUp($node->tag));
		}
		public function delete(binaryHeapNode $node){//ノード指定で削除する
			$this->delete_n($node->tag);
		}
		public function splice(binaryHeapNode $node){//ノード指定で取り出して削除する
			return $this->splice_n($node->tag);
		}
		protected function delete_n(int $tn){//番号指定で削除する
			if($tn>$this->cn){return false;}
			$this->d1_t[$tn]=$this->d1_t[$this->cn];
			unset($this->d1_t[$this->cn]);
			$this->cn--;
			$this->alignDown($this->alignUp($tn));
		}
		protected function splice_n(int $tn):binaryHeapNode{//番号指定でノードを取り出して削除する
			if($tn>$this->cn){return false;}
			$node=$this->d1_t[$tn];
			$this->delete_n($tn);
			return $node;
		}
		public function pop():binaryHeapNode{//最優先ノードを取り出して削除する
			return $this->splice_n(1);
		}
		public function top():binaryHeapNode{//最優先ノードを取得する
			return $this->d1_t[1];
		}
		public function count():int{//要素数を返す
			return $this->cn;
		}
		public function getIterator():\Traversable {
			return new \ArrayIterator($this->d1_t);
		}
		public function clear(){//ヒープを削除する
			$this->setup();
		}
		public function merge(self $heap){//同クラスの対象をこっちにマージする
			$otln=$heap->count;
			for($i1=0;$i1<$otln;$i1++){
				$this->push($heap->pop());
			}
		}
		public function getTree(){//ツリー本体を出力する
			return $this->d1_t;
		}
	}
	class binaryHeap implements \IteratorAggregate,\countable{
		protected $d1_n;//名前→ノード配列
		protected $heap;//binaryHeapObjオブジェクト
		//protected $kp;//内容配列における優先度の位置
		//protected $np;//内容配列における名前の位置
		//protected $rule;//0なら優先度が低いほど優先、1なら優先度が高いほど優先
		protected function setup(){
			$this->d1_n=array();
			$this->heap=new binaryHeapObj($this->rule);
		}
		public function __construct(protected $kp,protected $np=null,protected $rule=0){
			$this->setup();
		}
		public function push($d1_v){
			if($this->np===null){$this->doPush($d1_v);return;}
			$name=$d1_v[$this->np];
			if(isset($this->d1_n[$name])){return false;}
			else{$this->doPush($d1_v);}
		}
		public function change($d1_v){
			if($this->np===null){return false;}
			$name=$d1_v[$this->np];
			if(isset($this->d1_n[$name])){$this->doChange($d1_v);}
			else{return false;}
		}
		public function write($d1_v){
			if($this->np===null){$this->doPush($d1_v);return;}
			$name=$d1_v[$this->np];
			if(isset($this->d1_n[$name])){$this->doChange($d1_v);}
			else{$this->doPush($d1_v);}
		}
		public function doPush($d1_v){//内容配列からノードを生成、名前→ノード配列とヒープ本体に追加する
			$node=new binaryHeapNode($d1_v,$this->kp,$this->np);
			if($this->np!==null){$this->d1_n[$node->getName()]=$node;}
			$this->heap->push($node);
		}
		public function doChange($d1_v){//内容配列で同名ノードの内容を上書き
			$name=$d1_v[$this->np];
			$this->d1_n[$name]->setValue($d1_v);
			$this->heap->prioritize($this->d1_n[$name],$d1_v[$this->kp]);
		}
		public function rename($old,$new){//名前で指定したノードの名前だけを変更
			if($this->np===null){return false;}
			if(!array_key_exists($old,$this->d1_n)){return false;}
			if(array_key_exists($new,$this->d1_n)){return false;}
			$this->d1_n[$old]=$this->d1_n[$new];
			unset($this->d1_n[$old]);
			$this->d1_n[$new]->setName($new);
			return true;
		}
		public function top(){//最優先ノードの内容を出力
			return $this->heap->top()->getValue();
		}
		public function pop(){//最優先ノードの内容を出力して削除
			$node=$this->heap->pop();
			unset($this->d1_n[$node->getName()]);
			return $node->getValue();
		}
		protected function doDelete($name,$node){//deleteとspliceの共通処理
			$this->heap->delete($node);
			unset($this->d1_n[$name]);
		}
		public function delete($name){//名前で指定したノードを削除
			if($this->np===null){return false;}
			if(!array_key_exists($name,$this->d1_n)){return false;}
			$this->doDelete($name,$this->d1_n[$name]);
		}
		public function splice($name){//名前で指定したノードの内容を出力して削除
			if($this->np===null){return false;}
			if(!array_key_exists($name,$this->d1_n)){return false;}
			$node=$this->d1_n[$name];//出力内容の退避
			$this->doDelete($name,$node);
			return $node->getValue;
		}
		public function prioritize($name,$new){//
			if($this->np===null){return false;}
			if(!array_key_exists($name,$this->d1_n)){return false;}
			$this->heap->prioritize($this->d1_n[$name],$new);
		}
		public function count():int{
			return $this->heap->count();
		}
		public function getIterator():\Traversable {
			return new \ArrayIterator($this->d1_n);
		}
		public function getHeap(){
			return $this->heap;
		}
		public function merge(self $obj){
			$otln=$obj->count();
			for($i1=0;$i1<$otln;$i1++){
				$this->push($obj->pop());
			}
		}
	}
	class binomialHeapNode extends heapNode{
		public $degree;//次数　直接操作のみ　常に、0から次数―1までの次数個の子を持つ
		public $parent;//親ノード　直接操作のみ
		public $child;//子ノード配列　直接操作のみ　[0]には0次の、[1]には1次の子ノードが入る
		protected function setup(){
			$this->degree=0;
			$this->child=array();
		}
	
	}
	class binomialHeapObj implements \Iterator,\countable{
		protected $cn;//要素数
		protected $R;//全ての親ノード　例外的に、子に空きができる
		//protected $rule;//0なら優先度が低いほど優先、1なら優先度が高いほど優先
		protected $itr;//Iterator用のスタック
		protected $itrn;//Iterator用のカウント変数
		public $shell;//対応するbinomialHeapオブジェクト
		protected function setup(){
			$this->cn=0;
			$this->R=new binomialHeapNode(array(0),0);
			$this->R->parent=$this->R;
			$this->R->belong=$this;
		}
		public function __construct(protected $rule=0){
			$this->setup();
		}
		protected function compare(binomialHeapNode $node1,binomialHeapNode $node2){//ノードで比較、tn1の方が優先なら1、tn2の方が優先なら-1
			$kn1=$node1->getKey();
			$kn2=$node2->getKey();
			//echo "compare $tn1:$kn1 , $tn2:$kn2\n";
	
			if($this->rule==0){
				if($kn1<$kn2){return 1;}
				elseif($kn1>$kn2){return -1;}
				elseif($kn1==$kn2){return 0;}
			}else{
				if($kn1<$kn2){return -1;}
				elseif($kn1>$kn2){return 1;}
				elseif($kn1==$kn2){return 0;}
			}
		}
		protected function swapToUpper(binomialHeapNode $node):binomialHeapNode{//ノード指定で親と位置を交換して、交換後のノードを返す　すべての親とは交換しない　
			//echo"swap $tn1:$tn2\n";
			$parent=$node->parent;
			if($node->parent==$this->R){return false;}

			$parent->parent->child[$parent->degree]=$node;//親の親からの参照を修正
			foreach($node->child as $fenode){//対象の子からの参照を修正
				$fenode->parent=$parent;
			}
			foreach($parent->child as $fenode){//対象を含む、親の子からの参照を修正
				$fenode->parent=$node;
			}
			$parent->child[$node->degree]=$parent;//親から対象への参照を修正
	
			//対象と親の構造情報を交換
			list($node->child,$parent->child)=array($parent->child,$node->child);
			list($node->parent,$parent->parent)=array($parent->parent,$node->parent);
			list($node->degree,$parent->degree)=array($parent->degree,$node->degree);
			return $node;
		}
		protected function alignUp(binomialHeapNode $node):binomialHeapNode{//ノード指定で、親より優先度が高いなら親と交換、再帰的に繰り返して交換後のノードを返す
			if($node->parent==$this->R){return $node;}
			if($this->compare($node,$node->parent)>0){
				$node=$this->swapToUpper($node);
				return $this->alignUp($node);
			}else{
				return $node;
			}
		}
		protected function alignDown(binomialHeapNode $node):binomialHeapNode{//ノード指定で、より優先度の高い子と比較して優先度が低いなら交換、再帰的に繰り返して交換後のノードを返す
			if($node->degree==0){return $node;}
			$z_max=$node->child[0];
			for($i1=1;$i1<=$node->degree-1;$i1++){
				if($this->compare($node->child[$i1],$z_max)>0){
					$z_max=$node->child[$i1];
				}
			}
			if($this->compare($node,$z_max)<0){
				$this->swapToUpper($z_max);
				return $this->alignDown($z_max);
			}else{
				return $node;
			}
		}
		protected function extend(binomialHeapNode $child,binomialHeapNode $parent){//親無しのchildをparentの子に加える
			//childの親からの参照は操作しない
			$parent->child[$parent->degree]=$child;
			$parent->degree++;
			$child->parent=$parent;
		}
		public function push(binomialHeapNode $node){//ノードで0次要素をヒープに追加する
			$this->cn++;
			$this->add($node);
		}
		protected function add(binomialHeapNode $node):int{//親無しのノードをルートに追加する　最終的に追加された次数を返す
			//nodeの親からの参照は操作しない。先に消しておくこと
			$dn=$node->degree;
			$node->parent=$this->R;
			while(true){
				if(array_key_exists($dn,$this->R->child) and $this->R->child[$dn]!==null){
					$terget=$this->R->child[$dn];
					$this->R->child[$dn]=null;
					if($this->compare($node,$terget)>0){
						$this->extend($terget,$node);
						$dn++;
						continue;
					}else{
						$this->extend($node,$terget);
						$dn++;
						$node=$terget;
						continue;
					}
				}else{
					$this->R->child[$dn]=$node;
					return $dn;
				}
			}
		}
		public function prioritize(binomialHeapNode $node,$new){//対象ノードの優先度を新しい値に変更して、優先度に基づいた位置に移動させる
			$node->setKey($new);
			$this->alignDown($this->alignUp($node));
		}
		public function top():binomialHeapNode{//最優先ノードを取得する
			if($this->cn==0){return false;}
	
			$rtobj=null;
			foreach($this->R->child as $feobj){//全ての親の子の中から、最優先のものを探す
				if($rtobj===null){
					$rtobj=$feobj;
				}elseif($feobj===null){
				}elseif($this->compare($rtobj,$feobj)<0){
					$rtobj=$feobj;
				}
			}
			return $rtobj;
		}
		protected function deleteRoot(binomialHeapNode $node){//指定されたルートノードを削除する
			if($node->parent!=$this->R){return false;}
	
			$this->R->child[$node->degree]=null;
	
			for($i1=$node->degree-1;$i1>=0;$i1--){
				$this->add($node->child[$i1]);
			}
		}
		public function pop():binomialHeapNode{//最優先ノードを取り出して削除する
			$rtobj=$this->top();
			$this->deleteRoot($rtobj);
			$rtobj->parent=null;
			$rtobj->child=array();
			$rtobj->degree=0;
			$this->cn--;
			return $rtobj;
		}
		public function delete(binomialHeapNode $node){//ノード指定で削除する
			while($node->parent!=$this->R){
				$node=$this->swapToUpper($node);
			}
			$this->deleteRoot($node);
		}
		public function splice(binomialHeapNode $node):binomialHeapNode{//ノード指定で取り出して削除する
			$rtobj=$node;
			$this->delete($node);
			$rtobj->parent=null;
			$rtobj->child=array();
			$rtobj->degree=0;
			return $rtobj;
		}
		public function inThis(binomialHeapNode $node):bool{//このオブジェクトの全ての親に繋がるノードかどうか判定する
			$obj=$node;
			while($obj!=$obj->parent){
				$obj=$obj->parent;
				if(!is_a($obj,"binomialHeapNode")){return false;}
			}
			if($obj==$this->R){return true;}
			else{return false;}
		}
		public function count():int{//要素数を返す
			return $this->cn;
		}
	
		//Iteratorインターフェイス
			public function current(): mixed{
				return $this->itr->top();
			}
			public function key(): mixed{
				return $this->itrn;
			}
			public function next(): void{
				$otobj=$this->itr->pop();
				for($i2=$otobj->degree-1;$i2>=0;$i2--){
					$this->itr->push($otobj->child[$i2]);
				}
				$this->itrn++;
			}
			public function rewind(): void{
				$this->itr=new \SplStack();
				$this->itrn=0;
				if($this->count()==0){return;}
				$otar=array_reverse(array_keys($this->R->child));
				foreach($otar as $fen){
					if($this->R->child[$fen]===null){continue;}
					$this->itr->push($this->R->child[$fen]);
				}
			}
			public function valid(): bool{
				return $this->itr->count()>0;
			}
		//
		public function clear(){//ヒープを削除する
			$this->setup();
		}
		public function getRoot():binomialHeapNode{
			return $this->R;
		}
		public function merge(self $heap){//同クラスの対象をこっちにマージする
			$terget=$heap->getRoot();
			$otar=array_reverse(array_keys($terget->child));
			foreach($otar as $fen){
				if($terget->child[$fen]===null){continue;}
				$this->add($terget->child[$fen]);
			}
			$this->cn+=$heap->count();
		}
	}
	class binomialHeap implements \IteratorAggregate,\countable{
		protected $cn;//要素数
		protected $d1_n;//名前→ノード配列
		protected $heap;//binaryHeapObjオブジェクト
		//protected $kp;//内容配列における優先度の位置
		//protected $np;//内容配列における名前の位置
		//protected $rule;//0なら優先度が低いほど優先、1なら優先度が高いほど優先
		protected function setup(){
			$this->d1_n=array();
			$this->heap=new binomialHeapObj($this->rule);
			$this->heap->shell=$this;//ヒープオブジェクトからこちらを認識できるようにしておく
		}
		public function __construct(protected $kp,protected $np=null,protected $rule=0){
			$this->setup();
		}
		public function swapNode($name1,$name2){
			if($this->name_exists($name1) and $this->name_exists($name2)){
				list($this->d1_n[$name1],$this->d1_n[$name2])=array($this->d1_n[$name2],$this->d1_n[$name1]);
			}
		}
		public function push($d1_v){
			if($this->np===null){$this->doPush($d1_v);return;}
			$name=$d1_v[$this->np];
			if(isset($this->d1_n[$name])){return false;}
			else{$this->doPush($d1_v);}
		}
		public function change($d1_v){
			if($this->np===null){return false;}
			$name=$d1_v[$this->np];
			if(isset($this->d1_n[$name])){$this->doChange($d1_v);}
			else{return false;}
		}
		public function write($d1_v){
			if($this->np===null){$this->doPush($d1_v);return;}
			$name=$d1_v[$this->np];
			if(isset($this->d1_n[$name])){$this->doChange($d1_v);}
			else{$this->doPush($d1_v);}
		}
		public function doPush($d1_v){//内容配列からノードを生成、名前→ノード配列とヒープ本体に追加する
			$node=new binomialheapNode($d1_v,$this->kp,$this->np);
			if($this->np!==null){$this->d1_n[$node->getName()]=$node;}
			$this->heap->push($node);
		}
		public function doChange($d1_v){//内容配列で同名ノードの内容を上書き
			$name=$d1_v[$this->np];
			$this->d1_n[$name]->setValue($d1_v);
			$this->heap->prioritize($this->d1_n[$name],$d1_v[$this->kp]);
		}
		public function rename($old,$new){//名前で指定したノードの名前だけを変更
			if(!$this->name_exists($old)){return false;}
			if($this->name_exists($new)){return false;}
			$this->d1_n[$old]=$this->d1_n[$new];
			unset($this->d1_n[$old]);
			$this->d1_n[$new]->setName($new);
			return true;
		}
		public function top(){//最優先ノードの内容を出力
			return $this->heap->top()->getValue();
		}
		public function pop(){//最優先ノードの内容を出力して削除
			$node=$this->heap->pop();
			unset($this->d1_n[$node->getName()]);
			return $node->getValue();
		}
		protected function doDelete($name,$node){//deleteとspliceの共通処理
			$this->heap->delete($node);
			unset($this->d1_n[$name]);
		}
		public function name_exists($name):bool{//名前在りルール、かつ、その名前が存在するならtrue
			if($this->np===null){return false;}
			return array_key_exists($name,$this->d1_n);
		}
		public function delete($name){//名前で指定したノードを削除
			if(!$this->name_exists($name)){return false;}
			$this->doDelete($name,$this->d1_n[$name]);
		}
		public function splice($name){//名前で指定したノードの内容を出力して削除
			if(!$this->name_exists($name)){return false;}
			$node=$this->d1_n[$name];//出力内容の退避
			$this->doDelete($name,$node);
			return $node->getValue;
		}
		public function prioritize($name,$new){//
			if(!$this->name_exists($name)){return false;}
			$this->heap->prioritize($this->d1_n[$name],$new);
		}
		public function count():int{
			return $this->heap->count();
		}
		public function getIterator():\Traversable {
			return new \ArrayIterator($this->d1_n);
		}
		public function getHeap(){
			return $this->heap;
		}
		public function merge(self $obj){//名前被りは一切考慮していない
			if($this->np!==null){
				foreach($obj as $name=>$node){
					$this->d1_n[$name]=$node;
				}
			}
			$this->heap->merge($obj->getHeap());
		}
		public function getList(){//名前→内容配列を出力する
			$d2_rt=array();
			foreach($this->d1_n as $key=>$node){
				$d2_rt[$key]=$node->getValue();
			}
			return $d2_rt;
		}
	}
	class fibonacciHeapNode extends heapNode{
		public $degree;//子リンクの要素数
		public $damaged=false;//ダメージがあるならtrue
		public $parent;//親ノード　直接操作のみ
		public $child;//最優先子ノード配列
		public $next;//弟ノード
		public $prev;//兄ノード
		protected function setup(){
			$this->degree=0;
			$this->next=$this;
			$this->prev=$this;
		}
	}
	class fibonacciHeapObj implements \Iterator,\countable{
		protected $cn;//要素数
		protected $R;//全ての親ノード
		//protected $rule;//0なら優先度が低いほど優先、1なら優先度が高いほど優先
		protected $itr;//Iterator用のスタック
		protected $itrn;//Iterator用のカウント変数
		public $shell;//対応するfibonacciHeapオブジェクト
		protected $d1_m;//orgaize時に一旦整列させるための配列
		protected function setup(){
			$this->cn=0;
			$this->R=new fibonacciHeapNode(array(0,"ROOT"),0,1);//全ての親の名前はshellからは参照されないがデバッグ的に必要
			$this->R->parent=$this->R;
			$this->R->belong=$this;
			$this->d1_m=array();
		}
		public function __construct(protected $rule=0){
			$this->setup();
		}
		protected function compare_n(int|float $kn1,int|float $kn2){//prioritizeの判別の都合で作った。compareの内部としては使っていない(多少なりとも遅くなる)
			if($kn1==$kn2){return 0;}
			if($this->rule==0){
				if($kn1<$kn2){return 1;}
				elseif($kn1>$kn2){return -1;}
			}else{
				if($kn1<$kn2){return -1;}
				elseif($kn1>$kn2){return 1;}
			}
		}
		protected function compare(fibonacciHeapNode $node1,fibonacciHeapNode $node2){//ノードで比較、tn1の方が優先なら1、tn2の方が優先なら-1
			$kn1=$node1->getKey();
			$kn2=$node2->getKey();
			//echo "compare $tn1:$kn1 , $tn2:$kn2\n";
			if($kn1==$kn2){return 0;}
			if($this->rule==0){
				if($kn1<$kn2){return 1;}
				elseif($kn1>$kn2){return -1;}
			}else{
				if($kn1<$kn2){return -1;}
				elseif($kn1>$kn2){return 1;}
			}
		}
		protected function setMaxChild(fibonacciHeapNode $parent){//対象の子リンクの最優先ノードを更新する　organizeまではしない
			//echo"setMaxChild\n";
			$first=$parent->child;
			//$this->printNode($first);
			if($first===null){return;}
	
			$terget=$first;
			$z_max=$terget;
			while($terget->next!==$first){
				$terget=$terget->next;
				if($this->compare($z_max,$terget)<0){
					$z_max=$terget;
				}
			}
			$parent->child=$z_max;
		}
		protected function cutRoot(fibonacciHeapNode $node){//対象ノードを、親の子リンクから外す　親無しのノードだとエラー
			// echo"cutRoot\n";
			// $this->printNode($node);
			if($node===$this->R){return;}
	
			$parent=$node->parent;
	
			if($node->next!==$node){//兄弟がいる場合、リンク切断処理が入る
	
				if($parent->child===$node){//兄弟内での最優先ノードだった場合、最優先ノード更新処理が入る
					$next=$node->next;//とりあえず子のひとつを抽出しておく
				}else{
					$next=false;
				}
	
				$node->prev->next=$node->next;
				$node->next->prev=$node->prev;
	
				$node->next=$node;
				$node->prev=$node;
	
				//リンク切断処理の後に、最優先ノード更新処理。逆だとそりゃ更新されないわ。
				if($next){
					$parent->child=$next;//対象が最優先ノードだったときのみ、親の子は変更される
					$this->setMaxChild($parent);
				}
	
			}else{
				$parent->child=null;//兄弟がいない場合、親の子は無くなる
			}
			$parent->degree--;
			$node->parent=null;
	
			if($parent->parent===$this->R){return;}//全ての親とルートノードにダメージ判定は無い
	
			if($parent->damaged){//親のダメージ次第で連鎖的に切断する
				$this->cutRoot($parent);
			}else{
				$parent->damaged=true;
			}
	
		}
		protected function linkRoot(fibonacciHeapNode $child,fibonacciHeapNode $parent=null){//childをparentの子リンクに追加する。childは単独ノードとは限らない　childの元の親からの参照には触れない
			// echo"linkRoot\n";
			if($child===$this->R){return;}
			if($parent===null){$parent=$this->R;}
			// $this->printNode($child);
			// $this->printNode($parent);
	
			$terget=$child;//兄弟全員分の親を変更する
			$dn=0;//ついでに、加算される次数を数える
			do{
				$dn++;
				$terget->parent=$parent;
				$terget=$terget->next;
				if($parent==$this->R){$terget->damaged=false;}//ルートノードになる際にダメージは無くなる
			}while($terget!==$child);
	
			if($parent->child===null){
				$parent->child=$child;
			}else{
				list($child->prev,$parent->child->prev)=array($parent->child->prev,$child->prev);
				$child->prev->next=$child;
				$parent->child->prev->next=$parent->child;
	
				if($this->compare($child,$parent->child)>0){
					$parent->child=$child;
				}
			}
	
			$parent->degree+=$dn;//親の次数を修正
	
	
		}
		protected function organize_rc(fibonacciHeapNode $node){//d1_mに、繰上り込みで統合する　最終的にd1_mに入ったノードを返す
			// echo"organize_rc\n";
			// $this->printNode($node);
			// $this->printNodes();
			
			$dn=$node->degree;
			// echo"dn=$dn\n";
			//if($dn>$this->cn){exit();}//無限ループ強制終了用
			if(array_key_exists($dn,$this->d1_m)){
				// echo"hit\n";
				// $this->printNode($this->d1_m[$dn]);
				if($node===$this->R->child){//最優先ノードなら、同優先度だろうと何だろうと優先
					$this->cutRoot($this->d1_m[$dn]);
					$this->linkRoot($this->d1_m[$dn],$node);
				}elseif($this->compare($node,$this->d1_m[$dn])>0){
					$this->cutRoot($this->d1_m[$dn]);
					$this->linkRoot($this->d1_m[$dn],$node);
				}else{
					$this->cutRoot($node);
					$this->linkRoot($node,$this->d1_m[$dn]);
					$node=$this->d1_m[$dn];
				}
				unset($this->d1_m[$dn]);
				return $this->organize_rc($node);
			}else{
				//echo"no hit\n";
				$this->d1_m[$dn]=$node;
				return $node;
			}
	
		}
		public function organize(){//ルートリンクの、次数が同じ木を統合する
			//echo"organize\n";
			$terget=$this->R->child;
			//最優先ノードである、と言う前提に基づく。同優先度なら先にd1_mにセットされた方を根にする、と決めておけば、絶対にルートノードとして残る。
			//->ダメだ、最優先ノードと統合された後に繰り上がると、最優先ノードの方が追加側になってしまう。そうなると誤動作だ。
			//organize_rcのnodeが最優先ノードであった時点で、統合処理を別処理にしないと。
	
			// $this->printNode($terget);
			//$otln=0;
			do{
				//echo "otln=".$otln."\n";
				//$this->printNode($terget);
				//$otln++;
				// if($otln>$this->cn*2){exit();}//無限ループ強制終了用
				$next=$terget->next;
				$this->organize_rc($terget);
				// echo"rc end\n";
				$terget=$next;
				// $this->printNode($terget);
				// $this->printNode($this->R->child);
			}while($terget!==$this->R->child);
	
			$this->d1_m=array();
		}
		public function push(fibonacciHeapNode $node){//ノードで0次要素をヒープに追加する
			$this->cn++;
			$this->linkRoot($node);
		}
		public function prioritize(fibonacciHeapNode $node,$new){//対象ノードの優先度を新しい値に変更して、必要に応じて親子関係を切断する
			//echo"prioritize\n";
			if($this->compare_n($new,$node->getKey())==0){
				return;
			}elseif($this->compare_n($new,$node->getKey())>0){
				$this->priorityUp($node,$new);
			}else{
				$this->priorityDown($node,$new);
			}
		}
		public function priorityUp(fibonacciHeapNode $node,$new){//対象ノードの優先度を上昇させ、親を超えていれば切り離す
			$node->setKey($new);
			if($node->parent!==$this->R and $this->compare($node,$node->parent)>0){//ルートノードなら親とは比較しない
				$this->cutRoot($node);
				$this->linkRoot($node);
			}else{//親と切り離されなかった場合、子リンクの中での最優先ノードの変更の可能性があるので処理
				if($this->compare($node,$node->parent->child)>0){
					$node->parent->child=$node;
				}
			}
		}
		public function priorityDown(fibonacciHeapNode $node,$new){//対象ノードの優先度を減少させ、子を割っていれば切り離す
			$node->setKey($new);
			if($node->parent->child===$node){//最優先ノードだった場合、子リンクの中での最優先ノードの変更の可能性があるので処理
				$this->setMaxChild($node->parent);
			}
			if($node->child!==null and $this->compare($node,$node->child)<0){//子が無いなら子とは比較しない
				$this->linkRoot($node->child);
				$node->child=null;
				$node->degree=0;//linkRootは対象の親を操作しないので、こっちで色々やっておく
			}
		}
		public function top():fibonacciHeapNode{//最優先ノードを取得する
			//echo"top\n";
			if($this->cn==0){return false;}
			return $this->R->child;
		}
		protected function delete(fibonacciHeapNode $node){//指定されたノードを削除する
			//echo"delete\n";
			$this->cn--;//分岐の前に確実に要素数減少処理
			$this->cutRoot($node);
	
			if($node->child===null){return;}//対象に子があるとは限らない。
	
			$this->linkRoot($node->child);
			$node->child=null;
		}
		public function pop():fibonacciHeapNode{//最優先ノードを取り出して削除する
			//echo"pop $this->cn\n";
			//$this->obj_test_echo();
			if($this->cn==0){return false;}
			$this->organize();
			//echo"pop organized\n";
			//$this->printNodes();
			$rtobj=$this->top();
			$this->delete($rtobj);
			return $rtobj;
		}
		public function splice(fibonacciHeapNode $node):fibonacciHeapNode{//ノード指定で取り出して削除する
			$rtobj=$node;
			$this->delete($node);
			return $rtobj;
		}
		public function inThis(fibonacciHeapNode $node):bool{//このオブジェクトの全ての親に繋がるノードかどうか判定する
			$obj=$node;
			while($obj!=$obj->parent){
				$obj=$obj->parent;
				if(!is_a($obj,"fibonacciHeapNode")){return false;}
			}
			if($obj==$this->R){return true;}
			else{return false;}
		}
		public function count():int{//要素数を返す
			return $this->cn;
		}
	
		//Iteratorインターフェイス
			public function current(): mixed{
				return $this->itr->top();
			}
			public function key(): mixed{
				return $this->itrn;
			}
			public function next(): void{
				$first=$this->itr->pop()->child;
				if($first===null){return;}
	
				$terget=$first;
				do{
					$terget=$terget->prev;
					$this->itr->push($terget);
				}while($terget!==$first);
				$this->itrn++;
			}
			public function rewind(): void{
				$this->itr=new \SplStack();
				$this->itrn=0;
				$this->itr->push($this->R);
				$this->next();
			}
			public function valid(): bool{
				return $this->itr->count()>0;
			}
		//
		public function clear(){//ヒープを削除する
			$this->setup();
		}
		public function getRoot():fibonacciHeapNode{
			return $this->R;
		}
		public function merge(self $heap){//同クラスの対象をこっちにマージする
			$this->linkRoot($heap->getRoot()->child);
			$this->cn+=$heap->count();
			$heap->clear();
		}
	}
	class fibonacciHeap implements \IteratorAggregate,\countable{
		protected $cn;//要素数
		protected $d1_n;//名前→ノード配列
		protected $heap;//binaryHeapObjオブジェクト
		//protected $kp;//内容配列における優先度の位置
		//protected $np;//内容配列における名前の位置
		//protected $rule;//0なら優先度が低いほど優先、1なら優先度が高いほど優先
		protected function setup(){
			$this->d1_n=array();
			$this->heap=new fibonacciHeapObj($this->rule);
			$this->heap->shell=$this;//ヒープオブジェクトからこちらを認識できるようにしておく
		}
		public function __construct(protected $kp,protected $np=null,protected $rule=0){
			$this->setup();
		}
		public function swapNode($name1,$name2){
			if($this->name_exists($name1) and $this->name_exists($name2)){
				list($this->d1_n[$name1],$this->d1_n[$name2])=array($this->d1_n[$name2],$this->d1_n[$name1]);
			}
		}
		public function push($d1_v){
			if($this->np===null){$this->doPush($d1_v);return;}
			$name=$d1_v[$this->np];
			if(isset($this->d1_n[$name])){return false;}
			else{$this->doPush($d1_v);}
		}
		public function change($d1_v){
			if($this->np===null){return false;}
			$name=$d1_v[$this->np];
			if(isset($this->d1_n[$name])){$this->doChange($d1_v);}
			else{return false;}
		}
		public function write($d1_v){
			if($this->np===null){$this->doPush($d1_v);return;}
			$name=$d1_v[$this->np];
			if(isset($this->d1_n[$name])){$this->doChange($d1_v);}
			else{$this->doPush($d1_v);}
		}
		public function doPush($d1_v){//内容配列からノードを生成、名前→ノード配列とヒープ本体に追加する
			$node=new fibonacciheapNode($d1_v,$this->kp,$this->np);
			if($this->np!==null){$this->d1_n[$node->getName()]=$node;}
			$this->heap->push($node);
		}
		public function doChange($d1_v){//内容配列で同名ノードの内容を上書き
			$name=$d1_v[$this->np];
			$this->d1_n[$name]->setValue($d1_v);
			$this->heap->prioritize($this->d1_n[$name],$d1_v[$this->kp]);
		}
		public function rename($old,$new){//名前で指定したノードの名前だけを変更
			if(!$this->name_exists($old)){return false;}
			if($this->name_exists($new)){return false;}
			$this->d1_n[$old]=$this->d1_n[$new];
			unset($this->d1_n[$old]);
			$this->d1_n[$new]->setName($new);
			return true;
		}
		public function top(){//最優先ノードの内容を出力
			return $this->heap->top()->getValue();
		}
		public function pop(){//最優先ノードの内容を出力して削除
			$node=$this->heap->pop();
			unset($this->d1_n[$node->getName()]);
			return $node->getValue();
		}
		protected function doDelete($name,$node){//deleteとspliceの共通処理
			$this->heap->delete($node);
			unset($this->d1_n[$name]);
		}
		public function name_exists($name):bool{//名前在りルール、かつ、その名前が存在するならtrue
			if($this->np===null){return false;}
			return array_key_exists($name,$this->d1_n);
		}
		public function delete($name){//名前で指定したノードを削除
			if(!$this->name_exists($name)){return false;}
			$this->doDelete($name,$this->d1_n[$name]);
		}
		public function splice($name){//名前で指定したノードの内容を出力して削除
			if(!$this->name_exists($name)){return false;}
			$node=$this->d1_n[$name];//出力内容の退避
			$this->doDelete($name,$node);
			return $node->getValue;
		}
		public function prioritize($name,$new){//
			if(!$this->name_exists($name)){return false;}
			$this->heap->prioritize($this->d1_n[$name],$new);
		}
		public function count():int{
			return $this->heap->count();
		}
		public function getIterator():\Traversable {
			return new \ArrayIterator($this->d1_n);
		}
		public function getHeap(){
			return $this->heap;
		}
		public function merge(self $obj){//名前被りは一切考慮していない
			if($this->np!==null){
				foreach($obj as $name=>$node){
					$this->d1_n[$name]=$node;
				}
			}
			$this->heap->merge($obj->getHeap());
		}
		public function getList(){//名前→内容配列を出力する
			$d2_rt=array();
			foreach($this->d1_n as $key=>$node){
				$d2_rt[$key]=$node->getValue();
			}
			return $d2_rt;
		}
	}
}
namespace {
	//実験用のグローバル名前空間
	//srand(100);
	$ln_b=100000;
	$ln_k=100000;
	$ln_e=100000;
	$ln_c=100000;
	$d2_t=array();
	$d2_c=array();
	for($i1=0;$i1<$ln_b;$i1++){
		$d2_t[]=array(rand(0,$ln_k),rand(0,$ln_e));//$d2_t[名前]が、array(優先度,内容)となる。
	}
	$d2_tm=$d2_t;//変更後優先度を作るために、変更前の現在優先度をメモしておく。
	for($i1=0;$i1<$ln_c;$i1++){
		$otn=rand(0,$ln_b-1);
		//$d2_tm[$otn][0]=floor(($d2_tm[$otn][0])*rand(1,10)/10);
		$d2_tm[$otn][0]=$ln_k-floor(($ln_k-$d2_tm[$otn][0])*rand(1,10)/10);
		$d2_c[]=array($otn,$d2_tm[$otn][0]);//$d2_c[番号]が、array(名前,新しい優先度)となる。
	}
	timeCheck();
	echo"<br>\n";
	$testchecker=array();
	//$testchecker[0]=new \oldcode\binaryHeap(1,0,1);
	$testchecker[1]=new \crast\heap\shell(1,1,0,0);
	//$testchecker[2]=new \oldcode\binomialHeap(1,0,1);
	$testchecker[3]=new \crast\heap\shell(1,1,0,1);
	//$testchecker[4]=new \oldcode\fibonacciHeap(1,0,1);
	$testchecker[5]=new \crast\heap\shell(1,1,0,2);
	$testchecker[6]=new \crast\heap\shell(1,1,0,2);
	$testchecker[7]=new \crast\heap\shell(1,1,0,1);
	$testchecker[8]=new \crast\heap\shell(1,1,0,0);
	timecheck();
	echo"<br>\n";
	foreach($testchecker as $key=>$test){
		foreach($d2_t as $name=>$value){
			$test->push(array($name,$value[0],$value[1]));
		}
		echo"checked push   ";
		timeCheck();
		foreach($d2_c as $name=>$value){
			$test->prioritize($value[0],$value[1]);
		}
		echo"checked prioritize   ";
		timeCheck();
		while($test->count()>0){
			$otar=$test->pop();
			//echo"(".$otar[0].",".$otar[1].",".$otar[2].") ";
		}
		//echo"<br>\n";
		echo"checked pop   ";
		timeCheck();	
		echo"<br>\n";
	}

	//とりあえず、二部ヒープだけでも実験。
	//
	//$ln_b=100000;
	//$ln_k=10000;
	//$ln_e=10000;
	//$ln_c=100000;
	//の条件で、
	//checked push time_0.165
	//checked prioritize time_0.275
	//checked pop time_0.995
	//だったものが、
	//checked push time_0.386
	//checked prioritize time_0.032
	//checked pop time_0.667
	//という結果に。prioritizeがクソ速いというか、フィボナッチヒープの立つ瀬はどこよ。
	//popも大概早いんだけど、pushが異様に遅い。毎回のオブジェクト生成が遅いってことだろうか。
	//とりあえず多重継承無くしてみたけど、変わらず。これはほぼ影響ないのか。遠慮なく多重継承クラスを使おう。
	//new宣言を無駄に2回やってみる→0.03秒ほどしか遅くならない。ここはメインでは無さげ。
	//名前配列への入力では、わずかに$d1_v[$this->kp]よりも$node->getName()の方が速い気がするが、名前の長さとかにもよるのかもしんない。
	//issetの方が、array_key_existsするよりも誤差レベルで早い気がする……？
	//他の要素って何だ、何がある。ほとんどコピーで違いは無いぞ。
	//構造的には、alignが子クラスでの定義になったくらいだけど、それならprioritizeも条件は同じだ。
	//checked push time_0.376
	//checked prioritize time_0.168
	//checked pop time_0.719
	//いつの間にか、こんな感じになってた。prioritizeが爆速過ぎたのは、やっぱ何かおかしかっただけか……？
	//直接は関係ないけど、swapはalign以外で使っていなかったので、align内に書き込む。→目に見えるほどの差は無い感じ？
	//includeの向こう側とこっち側の違いみたいな可能性もあるか……？include使わずに、べた張りしてみる。
	//おー、だいぶ遅くなった。こいつが原因か。端っからincludeしたのが悪かったというか、include先の実験部分を流用したのが駄目か。
	//んー？全部こっちに移して、oldcodeは速くなったけど、shellは遅いままというか、一旦apache切って戻したら全体的に遅くなるとか、これもう自分の知識の及ばん範囲だな。
	//oldcodeの方も二部ヒープだけにして比較してみる。リロードするたびに、互角まで行くこともあるな。
	//同じtestcheckerに並んで入れて実験してみる。→だいぶ近づいた。けど、わずかに遅い感じだなあ。
	// time_0
	//
	// checked push time_0.169
	// checked prioritize time_0.214
	// checked pop time_0.972
	//
	// checked push time_0.178
	// checked prioritize time_0.181
	// checked pop time_0.679
	//
	//現状はこれで満足しておくしかないか。全体で見れば早くはなったわけだし。
	// checked push time_0.219
	// checked prioritize time_0.212
	// checked pop time_0.943
	
	// checked push time_0.208
	// checked prioritize time_0.067
	// checked pop time_0.604
	//
	//こんなんなったりもするけど、条件が分からねえ……。リロードするたびに変わりすぎだ実際。
	//そうだ、疑似乱数。そうすれば、乱数側か処理側かに問題を区別できるはずだ。
	//えーと、rand()とsrand()はmt_rand()とmt_stand()のエイリアスになっているから、単純にsrand()でシード値を指定すればいいのか。
	//確かに、数を減らして出力してみると、内容が固定されている。
	//でも、大量で処理すると、結構差が出る。まあ当然ではあるが。
	//こうしてみると、nodeクラスの多重継承止めるとprioritizeが速くなる感じか……？
	//となると、common抽象クラスを別に置くより、ひとまとめにした方が速いか？→pushとpopが微妙に遅くなっただけ。謎だ。
	//クラスの定義順を変えてみた→popはどっちが早いこともあるほぼ等速に。pushが遅れてるのは変わらずか。ほんとに微妙な違いだなー。
	//とりあえず新旧6つ揃えてみた。
	// checked push   time_0.225<br>
	// checked prioritize   time_0.214<br>
	// checked pop   time_0.957<br>
	// <br>
	// checked push   time_0.222<br>
	// checked prioritize   time_0.171<br>
	// checked pop   time_0.671<br>
	// <br>
	// checked push   time_0.2<br>
	// checked prioritize   time_0.242<br>
	// checked pop   time_1.213<br>
	// <br>
	// checked push   time_0.2<br>
	// checked prioritize   time_0.305<br>
	// checked pop   time_0.723<br>
	// <br>
	// checked push   time_0.195<br>
	// checked prioritize   time_0.112<br>
	// checked pop   time_2.445<br>
	// <br>
	// checked push   time_0.278<br>
	// checked prioritize   time_0.159<br>
	// checked pop   time_1.685<br>
	//重いのは、キャッシュできなくなった感じだろうか。
	//srand(100)で揃えて、ひとつひとつ試してみる。
	// checked push   time_0.169<br>
	// checked prioritize   time_0.215<br>
	// checked pop   time_0.951<br>
	// <br>
	// checked push   time_0.13<br>
	// checked prioritize   time_0.169<br>
	// checked pop   time_0.631<br>
	// <br>
	// checked push   time_0.115<br>
	// checked prioritize   time_0.304<br>
	// checked pop   time_1.147<br>
	// <br>
	// checked push   time_0.09<br>
	// checked prioritize   time_0.341<br>
	// checked pop   time_0.656<br>
	// <br>
	// checked push   time_0.104<br>
	// checked prioritize   time_0.108<br>
	// checked pop   time_2.405<br>
	// <br>
	// checked push   time_0.078<br>
	// checked prioritize   time_0.083<br>
	// checked pop   time_1.667<br>
	// <br>
	//
	//二項ヒープのprioritize以外は早くなってると言えるか。むしろ何でそこだけ悪化したんや。
	//→二項ヒープのprioritize処理がcompare相当処理の不等号の向き間違ってた。修正したらちゃんと改善した。ならよし。

	//全く同じ処理を2回するだけでも後の方が遅いので、コードの速さってのを突き詰めるのはかなりいろんなことを考慮する必要がありそうねー。
	//その辺分かってない現状では、これで限界としておくか。実際には弄りようはあるのかもしんないけど、分からん。
}

?>
